<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Design of Algorithms: TSP Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Design of Algorithms<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_t_s_p-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TSP Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_t_s_p_8h_source.html">TSP.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a78100470cf2a45cb6aaf8097b0170ac5" id="r_a78100470cf2a45cb6aaf8097b0170ac5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#a78100470cf2a45cb6aaf8097b0170ac5">setIsToyGraph</a> (<a class="el" href="class_edge.html">bool</a> <a class="el" href="class_t_s_p.html#a8ecc55dec57211910e18378e0e0fced8">isToyGraph</a>)</td></tr>
<tr class="separator:a78100470cf2a45cb6aaf8097b0170ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3097a75109f777a1b90ac74c26c9a3b" id="r_aa3097a75109f777a1b90ac74c26c9a3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#aa3097a75109f777a1b90ac74c26c9a3b">parseData</a> (std::string <a class="el" href="class_edge.html">nodesFilePath</a>, std::string <a class="el" href="class_edge.html">edgesFilePath</a>, <a class="el" href="class_edge.html">bool</a> <a class="el" href="class_edge.html">bothFilesProvided</a>)</td></tr>
<tr class="memdesc:aa3097a75109f777a1b90ac74c26c9a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that helps parse data.  <br /></td></tr>
<tr class="separator:aa3097a75109f777a1b90ac74c26c9a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e92f357e672ee5ffeca63dde9afc764" id="r_a0e92f357e672ee5ffeca63dde9afc764"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#a0e92f357e672ee5ffeca63dde9afc764">dataGoBoom</a> ()</td></tr>
<tr class="memdesc:a0e92f357e672ee5ffeca63dde9afc764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the data on program exit.  <br /></td></tr>
<tr class="separator:a0e92f357e672ee5ffeca63dde9afc764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cde97d885ad25cd1c46e88d688cdb7d" id="r_a9cde97d885ad25cd1c46e88d688cdb7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#a9cde97d885ad25cd1c46e88d688cdb7d">makeGraphConnected</a> ()</td></tr>
<tr class="memdesc:a9cde97d885ad25cd1c46e88d688cdb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the graph connected, and sets non-existing edges to infinite distance (Should only be used on Toy Graphs)  <br /></td></tr>
<tr class="separator:a9cde97d885ad25cd1c46e88d688cdb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7ed4984edf8f3743372ae35e254f67" id="r_adf7ed4984edf8f3743372ae35e254f67"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="class_edge.html">double</a>, std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#adf7ed4984edf8f3743372ae35e254f67">tspBTSetup</a> (<a class="el" href="class_edge.html">bool</a> <a class="el" href="class_edge.html">ignoreBound</a>)</td></tr>
<tr class="memdesc:adf7ed4984edf8f3743372ae35e254f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up function for the backtracking and bounding algorithm.  <br /></td></tr>
<tr class="separator:adf7ed4984edf8f3743372ae35e254f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550727387aeb56f0ce7eb55294c50809" id="r_a550727387aeb56f0ce7eb55294c50809"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#a550727387aeb56f0ce7eb55294c50809">cleanUpGraph</a> ()</td></tr>
<tr class="memdesc:a550727387aeb56f0ce7eb55294c50809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up the graph after making it connected.  <br /></td></tr>
<tr class="separator:a550727387aeb56f0ce7eb55294c50809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e17df6802c6bcc506b8e5e5bc1d6b3" id="r_a62e17df6802c6bcc506b8e5e5bc1d6b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#a62e17df6802c6bcc506b8e5e5bc1d6b3">triangularApproximation</a> (std::stringstream &amp;<a class="el" href="class_edge.html">sd</a>)</td></tr>
<tr class="memdesc:a62e17df6802c6bcc506b8e5e5bc1d6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an approximate solution to the <a class="el" href="class_t_s_p.html">TSP</a> using a triangular approximation.  <br /></td></tr>
<tr class="separator:a62e17df6802c6bcc506b8e5e5bc1d6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05391f65069f15e4d5b34a7c53ed88a5" id="r_a05391f65069f15e4d5b34a7c53ed88a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#a05391f65069f15e4d5b34a7c53ed88a5">otherHeuristic</a> ()</td></tr>
<tr class="memdesc:a05391f65069f15e4d5b34a7c53ed88a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Faster version of the Triangular Approximation Heuristic, analyzing only one cluster at a time instead of the whole network.  <br /></td></tr>
<tr class="separator:a05391f65069f15e4d5b34a7c53ed88a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247c98ae1a218b17fad37b6abefd0a7d" id="r_a247c98ae1a218b17fad37b6abefd0a7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#a247c98ae1a218b17fad37b6abefd0a7d">nnRecursion</a> (<a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">here</a>, <a class="el" href="class_edge.html">int</a> id, std::vector&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; &amp;path, <a class="el" href="class_edge.html">double</a> &amp;<a class="el" href="class_edge.html">count</a>, std::vector&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; &amp;<a class="el" href="class_edge.html">bestPath</a>, <a class="el" href="class_edge.html">double</a> &amp;<a class="el" href="class_edge.html">bestCount</a>)</td></tr>
<tr class="memdesc:a247c98ae1a218b17fad37b6abefd0a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a nearest neighbor recursion for the Travelling Salesman Problem (<a class="el" href="class_t_s_p.html">TSP</a>).  <br /></td></tr>
<tr class="separator:a247c98ae1a218b17fad37b6abefd0a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a3104bd5bde7dc1b30be4a3d82a151668" id="r_a3104bd5bde7dc1b30be4a3d82a151668"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#a3104bd5bde7dc1b30be4a3d82a151668">parsingGeoPointsAndEdges</a> (std::ifstream &amp;<a class="el" href="class_edge.html">in</a>)</td></tr>
<tr class="memdesc:a3104bd5bde7dc1b30be4a3d82a151668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that helps parsing the nodes/edges that are inside the csv.  <br /></td></tr>
<tr class="separator:a3104bd5bde7dc1b30be4a3d82a151668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5efe546aa75efa08aba4597389c3e7" id="r_a5e5efe546aa75efa08aba4597389c3e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#a5e5efe546aa75efa08aba4597389c3e7">parsingGeoPoints</a> (std::ifstream &amp;<a class="el" href="class_edge.html">in</a>)</td></tr>
<tr class="memdesc:a5e5efe546aa75efa08aba4597389c3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that helps parsing the nodes that are inside the csv.  <br /></td></tr>
<tr class="separator:a5e5efe546aa75efa08aba4597389c3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e31125379fdae552c5437ebb4e9963" id="r_a93e31125379fdae552c5437ebb4e9963"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#a93e31125379fdae552c5437ebb4e9963">parsingEdges</a> (std::ifstream &amp;<a class="el" href="class_edge.html">in</a>)</td></tr>
<tr class="memdesc:a93e31125379fdae552c5437ebb4e9963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that helps parsing the edges that are inside the csv.  <br /></td></tr>
<tr class="separator:a93e31125379fdae552c5437ebb4e9963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4e183d4cbec18d421f0bb4b4e8b957" id="r_a9e4e183d4cbec18d421f0bb4b4e8b957"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#a9e4e183d4cbec18d421f0bb4b4e8b957">tspRec</a> (<a class="el" href="class_edge.html">unsigned</a> <a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">numVertexes</a>, <a class="el" href="class_edge.html">unsigned</a> <a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">currentVertex</a>, <a class="el" href="class_edge.html">double</a> <a class="el" href="class_edge.html">curBestMin</a>, std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; * &gt; &amp;<a class="el" href="class_edge.html">curPath</a>, <a class="el" href="class_edge.html">double</a> &amp;<a class="el" href="class_edge.html">min</a>, std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; * &gt; &amp;<a class="el" href="class_edge.html">bestPath</a>, <a class="el" href="class_edge.html">bool</a> <a class="el" href="class_edge.html">ignoreBound</a>)</td></tr>
<tr class="memdesc:a9e4e183d4cbec18d421f0bb4b4e8b957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backtracking and Bounding algorithm to solve the <a class="el" href="class_t_s_p.html">TSP</a> for small graphs.  <br /></td></tr>
<tr class="separator:a9e4e183d4cbec18d421f0bb4b4e8b957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcef5d355c524a382a1699badeccf18" id="r_acfcef5d355c524a382a1699badeccf18"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#acfcef5d355c524a382a1699badeccf18">prim</a> (<a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; *<a class="el" href="class_edge.html">g</a>)</td></tr>
<tr class="memdesc:acfcef5d355c524a382a1699badeccf18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Minimum Spanning Tree (MST) of a graph using Prim's algorithm.  <br /></td></tr>
<tr class="separator:acfcef5d355c524a382a1699badeccf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110dcdab69f98951000452226dc3bb8f" id="r_a110dcdab69f98951000452226dc3bb8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#a110dcdab69f98951000452226dc3bb8f">createClusters</a> (std::vector&lt; std::set&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;<a class="el" href="class_edge.html">clusters</a>, std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;<a class="el" href="class_edge.html">centroids</a>, <a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">k</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; *<a class="el" href="class_edge.html">rootVertex</a>)</td></tr>
<tr class="memdesc:a110dcdab69f98951000452226dc3bb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates clusters of GeoPoints based on k and relative distance (K-means Clustering)  <br /></td></tr>
<tr class="separator:a110dcdab69f98951000452226dc3bb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd17b07eadc1fbb3ad6f9bcd937ad71e" id="r_acd17b07eadc1fbb3ad6f9bcd937ad71e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#acd17b07eadc1fbb3ad6f9bcd937ad71e">clusterPrim</a> (<a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; *<a class="el" href="class_edge.html">g</a>)</td></tr>
<tr class="memdesc:acd17b07eadc1fbb3ad6f9bcd937ad71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Prim's algorithm on a part of the graph (cluster), depending on which vertices are visited.  <br /></td></tr>
<tr class="separator:acd17b07eadc1fbb3ad6f9bcd937ad71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2726b78c9b3f50f6cf0387c12ae21ef2" id="r_a2726b78c9b3f50f6cf0387c12ae21ef2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#a2726b78c9b3f50f6cf0387c12ae21ef2">preOrderCluster</a> (<a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; *<a class="el" href="class_edge.html">root</a>, std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; * &gt; &amp;<a class="el" href="class_edge.html">preorder</a>)</td></tr>
<tr class="memdesc:a2726b78c9b3f50f6cf0387c12ae21ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a pre-order traversal on an MST.  <br /></td></tr>
<tr class="separator:a2726b78c9b3f50f6cf0387c12ae21ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f4581b120dc52e80425d65f05e58de" id="r_a05f4581b120dc52e80425d65f05e58de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#a05f4581b120dc52e80425d65f05e58de">getWeightBetween</a> (<a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; *<a class="el" href="class_edge.html">v1</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; *<a class="el" href="class_edge.html">v2</a>)</td></tr>
<tr class="memdesc:a05f4581b120dc52e80425d65f05e58de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the weight of an edge between two vertices.  <br /></td></tr>
<tr class="separator:a05f4581b120dc52e80425d65f05e58de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b72244e7a0750f7adb291e9152df75d" id="r_a0b72244e7a0750f7adb291e9152df75d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#a0b72244e7a0750f7adb291e9152df75d">isAdjacent</a> (<a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; *&amp;<a class="el" href="class_edge.html">v1</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; *&amp;<a class="el" href="class_edge.html">v2</a>)</td></tr>
<tr class="memdesc:a0b72244e7a0750f7adb291e9152df75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two vertices are adjacent in the graph.  <br /></td></tr>
<tr class="separator:a0b72244e7a0750f7adb291e9152df75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a52c17a3da6aa38689108dbe87e2978db" id="r_a52c17a3da6aa38689108dbe87e2978db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#a52c17a3da6aa38689108dbe87e2978db">recursionTimes</a> = 100000</td></tr>
<tr class="separator:a52c17a3da6aa38689108dbe87e2978db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecc55dec57211910e18378e0e0fced8" id="r_a8ecc55dec57211910e18378e0e0fced8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#a8ecc55dec57211910e18378e0e0fced8">isToyGraph</a> = <a class="el" href="class_edge.html">false</a></td></tr>
<tr class="separator:a8ecc55dec57211910e18378e0e0fced8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91790ffb4f28481d7f39769d00982ba6" id="r_a91790ffb4f28481d7f39769d00982ba6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#a91790ffb4f28481d7f39769d00982ba6">isExtraGraph</a> = <a class="el" href="class_edge.html">false</a></td></tr>
<tr class="separator:a91790ffb4f28481d7f39769d00982ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63bcbff82518756124e67ed93391781" id="r_aa63bcbff82518756124e67ed93391781"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#aa63bcbff82518756124e67ed93391781">numNodesFromExtra</a> = 25</td></tr>
<tr class="separator:aa63bcbff82518756124e67ed93391781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef716b23e8e4b4c2ae1d2d304df6077" id="r_a0ef716b23e8e4b4c2ae1d2d304df6077"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#a0ef716b23e8e4b4c2ae1d2d304df6077">tspNetwork</a></td></tr>
<tr class="separator:a0ef716b23e8e4b4c2ae1d2d304df6077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af073f6ce2f47770768054c6ec765007b" id="r_af073f6ce2f47770768054c6ec765007b"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#af073f6ce2f47770768054c6ec765007b">geoMap</a></td></tr>
<tr class="separator:af073f6ce2f47770768054c6ec765007b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3182f00392de6f7c96fe224b3bec1cb8" id="r_a3182f00392de6f7c96fe224b3bec1cb8"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#a3182f00392de6f7c96fe224b3bec1cb8">vertexGeoMap</a></td></tr>
<tr class="separator:a3182f00392de6f7c96fe224b3bec1cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b24ee9b169e4ea7003ee2b0e2d6696f" id="r_a3b24ee9b169e4ea7003ee2b0e2d6696f"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="class_edge.html">int</a>, std::set&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#a3b24ee9b169e4ea7003ee2b0e2d6696f">edgesGeoPoint</a></td></tr>
<tr class="separator:a3b24ee9b169e4ea7003ee2b0e2d6696f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f03e2284b99c53e47ab871c833c8996" id="r_a0f03e2284b99c53e47ab871c833c8996"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_p.html#a0f03e2284b99c53e47ab871c833c8996">edgesToRemove</a></td></tr>
<tr class="separator:a0f03e2284b99c53e47ab871c833c8996"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a550727387aeb56f0ce7eb55294c50809" name="a550727387aeb56f0ce7eb55294c50809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550727387aeb56f0ce7eb55294c50809">&#9670;&#160;</a></span>cleanUpGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> TSP::cleanUpGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleans up the graph after making it connected. </p>
<p>Time Complexity: O(K * E), where K is the number of edges to remove and E is the number of adjacent edges of the origin vertex </p>

</div>
</div>
<a id="acd17b07eadc1fbb3ad6f9bcd937ad71e" name="acd17b07eadc1fbb3ad6f9bcd937ad71e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd17b07eadc1fbb3ad6f9bcd937ad71e">&#9670;&#160;</a></span>clusterPrim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; * &gt; TSP::clusterPrim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes Prim's algorithm on a part of the graph (cluster), depending on which vertices are visited. </p>
<p>Time Complexity: O((V + E) * log(V)), where V is the number of vertices in the cluster and E is the number of edges in the cluster </p><dl class="section return"><dt>Returns</dt><dd>A set containing the MST of the cluster </dd></dl>

</div>
</div>
<a id="a110dcdab69f98951000452226dc3bb8f" name="a110dcdab69f98951000452226dc3bb8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110dcdab69f98951000452226dc3bb8f">&#9670;&#160;</a></span>createClusters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> TSP::createClusters </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::set&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a>&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; *&#160;</td>
          <td class="paramname"><em>rootVertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates clusters of GeoPoints based on k and relative distance (K-means Clustering) </p>
<p>Time Complexity: O(V * k), where V is the number of vertices in the graph and k is the number of clusters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clusters</td><td>vector of clusters to be filled </td></tr>
    <tr><td class="paramname">k</td><td>number of clusters to be created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e92f357e672ee5ffeca63dde9afc764" name="a0e92f357e672ee5ffeca63dde9afc764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e92f357e672ee5ffeca63dde9afc764">&#9670;&#160;</a></span>dataGoBoom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> TSP::dataGoBoom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the data on program exit. </p>

</div>
</div>
<a id="a05f4581b120dc52e80425d65f05e58de" name="a05f4581b120dc52e80425d65f05e58de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f4581b120dc52e80425d65f05e58de">&#9670;&#160;</a></span>getWeightBetween()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> TSP::getWeightBetween </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; *&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the weight of an edge between two vertices. </p>
<p>Time Complexity: O(E), where E is the number of outgoing edges of v1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>Origin vertex </td></tr>
    <tr><td class="paramname">v2</td><td>Destination vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>weight between v1 and v2 </dd></dl>

</div>
</div>
<a id="a0b72244e7a0750f7adb291e9152df75d" name="a0b72244e7a0750f7adb291e9152df75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b72244e7a0750f7adb291e9152df75d">&#9670;&#160;</a></span>isAdjacent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">bool</a> TSP::isAdjacent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; *&amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; *&amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two vertices are adjacent in the graph. </p>
<p>This function checks if there is an edge between the vertices <code>v1</code> and <code>v2</code>. It has time complexity of O(E), being E the edges of vertex v1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>A reference to a pointer to the first vertex. </td></tr>
    <tr><td class="paramname">v2</td><td>A reference to a pointer to the second vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>v1</code> and <code>v2</code> are adjacent, false otherwise. </dd></dl>

</div>
</div>
<a id="a9cde97d885ad25cd1c46e88d688cdb7d" name="a9cde97d885ad25cd1c46e88d688cdb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cde97d885ad25cd1c46e88d688cdb7d">&#9670;&#160;</a></span>makeGraphConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">bool</a> TSP::makeGraphConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes the graph connected, and sets non-existing edges to infinite distance (Should only be used on Toy Graphs) </p>
<p>Time Complexity: O(V * V * E), where V is the number of vertices in the graph and E is the number of adjacent edges of each vertex </p><dl class="section return"><dt>Returns</dt><dd>Returns a bool telling if the graph was already connected or not </dd></dl>

</div>
</div>
<a id="a247c98ae1a218b17fad37b6abefd0a7d" name="a247c98ae1a218b17fad37b6abefd0a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247c98ae1a218b17fad37b6abefd0a7d">&#9670;&#160;</a></span>nnRecursion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">bool</a> TSP::nnRecursion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a>&#160;</td>
          <td class="paramname"><em>here</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>bestPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>bestCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a nearest neighbor recursion for the Travelling Salesman Problem (<a class="el" href="class_t_s_p.html">TSP</a>). </p>
<p>This function implements the nearest neighbor heuristic to find an approximate solution to the Travelling Salesman Problem. It recursively explores paths from the current vertex to its adjacent vertices, selecting the edge with the minimum weight that hasn't been selected yet. It updates the best path and count of the path length found so far. The function is bounded by the global variable recursionTimes, that guarantees that if a recursion level has reached 100 thousand levels deep, the recursion must end, even if there's no answer to that point.</p>
<p>The function has average time complexity of O(10^5 * E²), however, in the worst case where E = V² it has time complexity of O(10^5 * V^4)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">here</td><td>The ID of the current vertex. </td></tr>
    <tr><td class="paramname">id</td><td>The ID of the previous vertex, used to avoid going back to the same vertex immediately. </td></tr>
    <tr><td class="paramname">path</td><td>A reference to the vector storing the current path of GeoPoints. </td></tr>
    <tr><td class="paramname">count</td><td>A reference to the current path length. </td></tr>
    <tr><td class="paramname">bestPath</td><td>A reference to the vector storing the best path of GeoPoints found so far. </td></tr>
    <tr><td class="paramname">bestCount</td><td>A reference to the length of the best path found so far. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a complete tour is found; otherwise, false. </dd></dl>

</div>
</div>
<a id="a05391f65069f15e4d5b34a7c53ed88a5" name="a05391f65069f15e4d5b34a7c53ed88a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05391f65069f15e4d5b34a7c53ed88a5">&#9670;&#160;</a></span>otherHeuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> TSP::otherHeuristic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Faster version of the Triangular Approximation Heuristic, analyzing only one cluster at a time instead of the whole network. </p>
<p>Time Complexity: O(k * ((V + E) * log(V))), where k is the number of clusters and ((V + E) * log) is the complexity of Prim's algorithm for a cluster </p><dl class="section return"><dt>Returns</dt><dd>Total distance </dd></dl>

</div>
</div>
<a id="aa3097a75109f777a1b90ac74c26c9a3b" name="aa3097a75109f777a1b90ac74c26c9a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3097a75109f777a1b90ac74c26c9a3b">&#9670;&#160;</a></span>parseData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> TSP::parseData </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>nodesFilePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>edgesFilePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">bool</a>&#160;</td>
          <td class="paramname"><em>bothFilesProvided</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that helps parse data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bothFilesProvided</td><td>If false the first argument will contain the file that incorporates both nodes / edges. If true then first argument will contain the file path for the nodes csv and the second argument will contain the file path for the edges csv. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93e31125379fdae552c5437ebb4e9963" name="a93e31125379fdae552c5437ebb4e9963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e31125379fdae552c5437ebb4e9963">&#9670;&#160;</a></span>parsingEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> TSP::parsingEdges </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that helps parsing the edges that are inside the csv. </p>
<p>Time Complexity: O(E), where E is the number of edges to be parsed</p>
<p>This functions expects the following order: origin, destination, haversine_distance. </p>

</div>
</div>
<a id="a5e5efe546aa75efa08aba4597389c3e7" name="a5e5efe546aa75efa08aba4597389c3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5efe546aa75efa08aba4597389c3e7">&#9670;&#160;</a></span>parsingGeoPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> TSP::parsingGeoPoints </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that helps parsing the nodes that are inside the csv. </p>
<p>Time Complexity: O(V), where V is the number of nodes to be parsed</p>
<p>This functions expects the following order: id, longitude, latitude. </p>

</div>
</div>
<a id="a3104bd5bde7dc1b30be4a3d82a151668" name="a3104bd5bde7dc1b30be4a3d82a151668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3104bd5bde7dc1b30be4a3d82a151668">&#9670;&#160;</a></span>parsingGeoPointsAndEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> TSP::parsingGeoPointsAndEdges </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that helps parsing the nodes/edges that are inside the csv. </p>
<p>Time Complexity: O(V + E), where V is the number of nodes and E the number of edges to be parsed</p>
<p>This functions expects the following order: </p><pre class="fragment">         "origin, destination, distance" or "origin, destination, distance, label origin, label destination"
</pre> 
</div>
</div>
<a id="a2726b78c9b3f50f6cf0387c12ae21ef2" name="a2726b78c9b3f50f6cf0387c12ae21ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2726b78c9b3f50f6cf0387c12ae21ef2">&#9670;&#160;</a></span>preOrderCluster()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> TSP::preOrderCluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>preorder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does a pre-order traversal on an MST. </p>
<p>Time Complexity: O(VE), where V is the number of vertices in the MST and E is the number of edges of each vertex </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>root node of the pre-order traversal </td></tr>
    <tr><td class="paramname">preorder</td><td>vector that contains the solution (vertices in preorder) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfcef5d355c524a382a1699badeccf18" name="acfcef5d355c524a382a1699badeccf18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcef5d355c524a382a1699badeccf18">&#9670;&#160;</a></span>prim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; * &gt; TSP::prim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Minimum Spanning Tree (MST) of a graph using Prim's algorithm. </p>
<p>This function computes the MST of the given graph <code>g</code> using Prim's algorithm. It returns the vertices of the MST in the order they are visited. It has time complexity of O(E*log(V))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>A pointer to the graph on which Prim's algorithm is to be executed. </td></tr>
    <tr><td class="paramname">visitOrder</td><td>A reference to a vector that will store the order in which vertices are visited. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vertices that are part of the MST. </dd></dl>

</div>
</div>
<a id="a78100470cf2a45cb6aaf8097b0170ac5" name="a78100470cf2a45cb6aaf8097b0170ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78100470cf2a45cb6aaf8097b0170ac5">&#9670;&#160;</a></span>setIsToyGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> TSP::setIsToyGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">bool</a>&#160;</td>
          <td class="paramname"><em>isToyGraph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a62e17df6802c6bcc506b8e5e5bc1d6b3" name="a62e17df6802c6bcc506b8e5e5bc1d6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e17df6802c6bcc506b8e5e5bc1d6b3">&#9670;&#160;</a></span>triangularApproximation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> TSP::triangularApproximation </td>
          <td>(</td>
          <td class="paramtype">std::stringstream &amp;&#160;</td>
          <td class="paramname"><em>sd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes an approximate solution to the <a class="el" href="class_t_s_p.html">TSP</a> using a triangular approximation. </p>
<p>This function computes an approximate solution to the Traveling Salesman Problem (<a class="el" href="class_t_s_p.html">TSP</a>) using a minimum spanning tree (MST) and a pre-order traversal of the MST. The solution might not be optimal but provides a feasible route even in non-fully connected graphs.</p>
<p>It has time complexity O(V+E*log(V)), bounded by Prim's Algorithm Complexity</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sd</td><td>A stringstream to store the sequence of visited vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total cost of the tour. </dd></dl>

</div>
</div>
<a id="adf7ed4984edf8f3743372ae35e254f67" name="adf7ed4984edf8f3743372ae35e254f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7ed4984edf8f3743372ae35e254f67">&#9670;&#160;</a></span>tspBTSetup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="class_edge.html">double</a>, std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; * &gt; &gt; TSP::tspBTSetup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">bool</a>&#160;</td>
          <td class="paramname"><em>ignoreBound</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up function for the backtracking and bounding algorithm. </p>
<p>Time Complexity: O(N!), because it calls the backtracking and bounding recursive function </p><dl class="section return"><dt>Returns</dt><dd>Returns the minimum distance of the circuit and the corresponding circuit </dd></dl>

</div>
</div>
<a id="a9e4e183d4cbec18d421f0bb4b4e8b957" name="a9e4e183d4cbec18d421f0bb4b4e8b957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4e183d4cbec18d421f0bb4b4e8b957">&#9670;&#160;</a></span>tspRec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> TSP::tspRec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">unsigned</a> <a class="el" href="class_edge.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">unsigned</a> <a class="el" href="class_edge.html">int</a>&#160;</td>
          <td class="paramname"><em>curI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a>&#160;</td>
          <td class="paramname"><em>curDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>curPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>minDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_geo_point.html">GeoPoint</a> * &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">bool</a>&#160;</td>
          <td class="paramname"><em>ignoreBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Backtracking and Bounding algorithm to solve the <a class="el" href="class_t_s_p.html">TSP</a> for small graphs. </p>
<p>Time Complexity: O(N!), where N is the number of nodes in the graph </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>number of nodes in the graph </td></tr>
    <tr><td class="paramname">curI</td><td>current index </td></tr>
    <tr><td class="paramname">curDist</td><td>current distance </td></tr>
    <tr><td class="paramname">curPath</td><td>current path </td></tr>
    <tr><td class="paramname">minDist</td><td>minimum distance </td></tr>
    <tr><td class="paramname">path</td><td>vector that contains the paths </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3b24ee9b169e4ea7003ee2b0e2d6696f" name="a3b24ee9b169e4ea7003ee2b0e2d6696f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b24ee9b169e4ea7003ee2b0e2d6696f">&#9670;&#160;</a></span>edgesGeoPoint</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;<a class="el" href="class_edge.html">int</a>, std::set&lt;<a class="el" href="class_geo_point.html">GeoPoint</a>*&gt; &gt; TSP::edgesGeoPoint</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f03e2284b99c53e47ab871c833c8996" name="a0f03e2284b99c53e47ab871c833c8996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f03e2284b99c53e47ab871c833c8996">&#9670;&#160;</a></span>edgesToRemove</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_edge.html">Edge</a>&lt;<a class="el" href="class_geo_point.html">GeoPoint</a>*&gt; &gt; TSP::edgesToRemove</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af073f6ce2f47770768054c6ec765007b" name="af073f6ce2f47770768054c6ec765007b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af073f6ce2f47770768054c6ec765007b">&#9670;&#160;</a></span>geoMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;<a class="el" href="class_edge.html">int</a>, <a class="el" href="class_geo_point.html">GeoPoint</a>*&gt; TSP::geoMap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a91790ffb4f28481d7f39769d00982ba6" name="a91790ffb4f28481d7f39769d00982ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91790ffb4f28481d7f39769d00982ba6">&#9670;&#160;</a></span>isExtraGraph</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">bool</a> TSP::isExtraGraph = <a class="el" href="class_edge.html">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ecc55dec57211910e18378e0e0fced8" name="a8ecc55dec57211910e18378e0e0fced8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ecc55dec57211910e18378e0e0fced8">&#9670;&#160;</a></span>isToyGraph</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">bool</a> TSP::isToyGraph = <a class="el" href="class_edge.html">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa63bcbff82518756124e67ed93391781" name="aa63bcbff82518756124e67ed93391781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63bcbff82518756124e67ed93391781">&#9670;&#160;</a></span>numNodesFromExtra</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">int</a> TSP::numNodesFromExtra = 25</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a52c17a3da6aa38689108dbe87e2978db" name="a52c17a3da6aa38689108dbe87e2978db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c17a3da6aa38689108dbe87e2978db">&#9670;&#160;</a></span>recursionTimes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">int</a> TSP::recursionTimes = 100000</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ef716b23e8e4b4c2ae1d2d304df6077" name="a0ef716b23e8e4b4c2ae1d2d304df6077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef716b23e8e4b4c2ae1d2d304df6077">&#9670;&#160;</a></span>tspNetwork</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a>&lt;<a class="el" href="class_geo_point.html">GeoPoint</a>*&gt; TSP::tspNetwork</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3182f00392de6f7c96fe224b3bec1cb8" name="a3182f00392de6f7c96fe224b3bec1cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3182f00392de6f7c96fe224b3bec1cb8">&#9670;&#160;</a></span>vertexGeoMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;<a class="el" href="class_edge.html">int</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt;<a class="el" href="class_geo_point.html">GeoPoint</a>*&gt;*&gt; TSP::vertexGeoMap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/antonioabilio/Desktop/DA-TSP-Proj2/src/<a class="el" href="_t_s_p_8h_source.html">TSP.h</a></li>
<li>/Users/antonioabilio/Desktop/DA-TSP-Proj2/src/<a class="el" href="_t_s_p_8cpp.html">TSP.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
